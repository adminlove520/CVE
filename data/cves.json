{
  "dataType": "CVE_RECORD",
  "dataVersion": "5.1",
  "cveMetadata": {
    "total_count": 3,
    "last_updated": "2025-10-10T20:52:28.794634",
    "severity_distribution": {
      "critical": 1,
      "high": 2,
      "medium": 0,
      "low": 0,
      "none": 0
    }
  },
  "cves": [
    {
      "id": "CVE-2025-61929",
      "publishedDate": "2025-10-10T19:50:14.036Z",
      "lastModifiedDate": "2025-10-10T20:46:08.118Z",
      "description": "Cherry Studio is a desktop client that supports for multiple LLM providers. Cherry Studio registers a custom protocol called `cherrystudio://`. When handling the MCP installation URL, it parses the base64-encoded configuration data and directly executes the command within it. In the files `src/main/services/ProtocolClient.ts` and `src/main/services/urlschema/mcp-install.ts`, when receiving a URL of the `cherrystudio://mcp` type, the `handleMcpProtocolUrl` function is called for processing. If an attacker crafts malicious content and posts it on a website or elsewhere (there are many exploitation methods, such as creating a malicious website with a button containing this malicious content), when the user clicks it, since the pop-up window contains normal content, the direct click is considered a scene action, and the malicious command is directly triggered, leading to the user being compromised. As of time of publication, no known patched versions exist.",
      "severity": 9.7,
      "references": [
        {
          "url": "https://github.com/CherryHQ/cherry-studio/security/advisories/GHSA-hh6w-rmjc-26f6",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "vendor": "CherryHQ",
          "product": "cherry-studio",
          "versions": [
            {
              "version": "<= 1.7.0-alpha.4",
              "status": "affected"
            }
          ]
        }
      ],
      "problemType": [
        "CWE-94: Improper Control of Generation of Code ('Code Injection')"
      ],
      "fix_suggestion": "无法生成修复建议"
    },
    {
      "id": "CVE-2025-61920",
      "publishedDate": "2025-10-10T19:25:07.679Z",
      "lastModifiedDate": "2025-10-10T20:47:08.736Z",
      "description": "Authlib is a Python library which builds OAuth and OpenID Connect servers. Prior to version 1.6.5, Authlib’s JOSE implementation accepts unbounded JWS/JWT header and signature segments. A remote attacker can craft a token whose base64url‑encoded header or signature spans hundreds of megabytes. During verification, Authlib decodes and parses the full input before it is rejected, driving CPU and memory consumption to hostile levels and enabling denial of service. Version 1.6.5 patches the issue. Some temporary workarounds are available. Enforce input size limits before handing tokens to Authlib and/or use application-level throttling to reduce amplification risk.",
      "severity": 7.5,
      "references": [
        {
          "url": "https://github.com/authlib/authlib/security/advisories/GHSA-pq5p-34cr-23v9",
          "type": "reference"
        },
        {
          "url": "https://github.com/authlib/authlib/commit/867e3f87b072347a1ae9cf6983cc8bbf88447e5e",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "vendor": "authlib",
          "product": "authlib",
          "versions": [
            {
              "version": "< 1.6.5",
              "status": "affected"
            }
          ]
        }
      ],
      "problemType": [
        "CWE-20: Improper Input Validation",
        "CWE-400: Uncontrolled Resource Consumption",
        "CWE-770: Allocation of Resources Without Limits or Throttling"
      ],
      "fix_suggestion": "无法生成修复建议"
    },
    {
      "id": "CVE-2025-61919",
      "publishedDate": "2025-10-10T19:22:42.454Z",
      "lastModifiedDate": "2025-10-10T20:48:20.240Z",
      "description": "Rack is a modular Ruby web server interface. Prior to versions 2.2.20, 3.1.18, and 3.2.3, `Rack::Request#POST` reads the entire request body into memory for `Content-Type: application/x-www-form-urlencoded`, calling `rack.input.read(nil)` without enforcing a length or cap. Large request bodies can therefore be buffered completely into process memory before parsing, leading to denial of service (DoS) through memory exhaustion. Users should upgrade to Rack version 2.2.20, 3.1.18, or 3.2.3, anu of which enforces form parameter limits using `query_parser.bytesize_limit`, preventing unbounded reads of `application/x-www-form-urlencoded` bodies. Additionally, enforce strict maximum body size at the proxy or web server layer (e.g., Nginx `client_max_body_size`, Apache `LimitRequestBody`).",
      "severity": 7.5,
      "references": [
        {
          "url": "https://github.com/rack/rack/security/advisories/GHSA-6xw4-3v39-52mm",
          "type": "reference"
        },
        {
          "url": "https://github.com/rack/rack/commit/4e2c903991a790ee211a3021808ff4fd6fe82881",
          "type": "reference"
        },
        {
          "url": "https://github.com/rack/rack/commit/cbd541e8a3d0c5830a3c9a30d3718ce2e124f9db",
          "type": "reference"
        },
        {
          "url": "https://github.com/rack/rack/commit/e179614c4a653283286f5f046428cbb85f21146f",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "vendor": "rack",
          "product": "rack",
          "versions": [
            {
              "version": "< 2.2.20",
              "status": "affected"
            },
            {
              "version": ">= 3.0, < 3.1.18",
              "status": "affected"
            },
            {
              "version": ">= 3.2, < 3.2.3",
              "status": "affected"
            }
          ]
        }
      ],
      "problemType": [
        "CWE-400: Uncontrolled Resource Consumption"
      ],
      "fix_suggestion": "无法生成修复建议"
    }
  ]
}