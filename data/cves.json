{
  "dataType": "CVE_RECORD",
  "dataVersion": "5.1",
  "cveMetadata": {
    "total_count": 2,
    "last_updated": "2025-12-04T13:02:34.145893",
    "severity_distribution": {
      "critical": 0,
      "high": 0,
      "medium": 0,
      "low": 0,
      "none": 2
    }
  },
  "cves": [
    {
      "id": "CVE-2025-40215",
      "publishedDate": "2025-12-04T12:38:32.517Z",
      "lastModifiedDate": "2025-12-04T12:38:32.517Z",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm: delete x->tunnel as we delete x\n\nThe ipcomp fallback tunnels currently get deleted (from the various\nlists and hashtables) as the last user state that needed that fallback\nis destroyed (not deleted). If a reference to that user state still\nexists, the fallback state will remain on the hashtables/lists,\ntriggering the WARN in xfrm_state_fini. Because of those remaining\nreferences, the fix in commit f75a2804da39 (\"xfrm: destroy xfrm_state\nsynchronously on net exit path\") is not complete.\n\nWe recently fixed one such situation in TCP due to defered freeing of\nskbs (commit 9b6412e6979f (\"tcp: drop secpath at the same time as we\ncurrently drop dst\")). This can also happen due to IP reassembly: skbs\nwith a secpath remain on the reassembly queue until netns\ndestruction. If we can't guarantee that the queues are flushed by the\ntime xfrm_state_fini runs, there may still be references to a (user)\nxfrm_state, preventing the timely deletion of the corresponding\nfallback state.\n\nInstead of chasing each instance of skbs holding a secpath one by one,\nthis patch fixes the issue directly within xfrm, by deleting the\nfallback state as soon as the last user state depending on it has been\ndeleted. Destruction will still happen when the final reference is\ndropped.\n\nA separate lockdep class for the fallback state is required since\nwe're going to lock x->tunnel while x is locked.",
      "severity": "N/A",
      "references": [
        {
          "url": "https://git.kernel.org/stable/c/b441cf3f8c4b8576639d20c8eb4aa32917602ecd",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "product": "Linux",
          "vendor": "Linux",
          "defaultStatus": "unaffected",
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "programFiles": [
            "include/net/xfrm.h",
            "net/ipv4/ipcomp.c",
            "net/ipv6/ipcomp6.c",
            "net/ipv6/xfrm6_tunnel.c",
            "net/xfrm/xfrm_ipcomp.c",
            "net/xfrm/xfrm_state.c"
          ],
          "versions": [
            {
              "version": "9d4139c76905833afcb77fe8ccc17f302a0eb9ab",
              "lessThan": "b441cf3f8c4b8576639d20c8eb4aa32917602ecd",
              "status": "affected",
              "versionType": "git"
            }
          ]
        },
        {
          "product": "Linux",
          "vendor": "Linux",
          "defaultStatus": "affected",
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "programFiles": [
            "include/net/xfrm.h",
            "net/ipv4/ipcomp.c",
            "net/ipv6/ipcomp6.c",
            "net/ipv6/xfrm6_tunnel.c",
            "net/xfrm/xfrm_ipcomp.c",
            "net/xfrm/xfrm_state.c"
          ],
          "versions": [
            {
              "version": "2.6.29",
              "status": "affected"
            },
            {
              "version": "0",
              "lessThan": "2.6.29",
              "status": "unaffected",
              "versionType": "semver"
            },
            {
              "version": "6.16",
              "lessThanOrEqual": "*",
              "status": "unaffected",
              "versionType": "original_commit_for_fix"
            }
          ]
        }
      ],
      "problemType": [],
      "fix_suggestion": "无法生成修复建议"
    },
    {
      "id": "CVE-2025-40214",
      "publishedDate": "2025-12-04T12:38:31.601Z",
      "lastModifiedDate": "2025-12-04T12:38:31.601Z",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Initialise scc_index in unix_add_edge().\n\nQuang Le reported that the AF_UNIX GC could garbage-collect a\nreceive queue of an alive in-flight socket, with a nice repro.\n\nThe repro consists of three stages.\n\n  1)\n    1-a. Create a single cyclic reference with many sockets\n    1-b. close() all sockets\n    1-c. Trigger GC\n\n  2)\n    2-a. Pass sk-A to an embryo sk-B\n    2-b. Pass sk-X to sk-X\n    2-c. Trigger GC\n\n  3)\n    3-a. accept() the embryo sk-B\n    3-b. Pass sk-B to sk-C\n    3-c. close() the in-flight sk-A\n    3-d. Trigger GC\n\nAs of 2-c, sk-A and sk-X are linked to unix_unvisited_vertices,\nand unix_walk_scc() groups them into two different SCCs:\n\n  unix_sk(sk-A)->vertex->scc_index = 2 (UNIX_VERTEX_INDEX_START)\n  unix_sk(sk-X)->vertex->scc_index = 3\n\nOnce GC completes, unix_graph_grouped is set to true.\nAlso, unix_graph_maybe_cyclic is set to true due to sk-X's\ncyclic self-reference, which makes close() trigger GC.\n\nAt 3-b, unix_add_edge() allocates unix_sk(sk-B)->vertex and\nlinks it to unix_unvisited_vertices.\n\nunix_update_graph() is called at 3-a. and 3-b., but neither\nunix_graph_grouped nor unix_graph_maybe_cyclic is changed\nbecause both sk-B's listener and sk-C are not in-flight.\n\n3-c decrements sk-A's file refcnt to 1.\n\nSince unix_graph_grouped is true at 3-d, unix_walk_scc_fast()\nis finally called and iterates 3 sockets sk-A, sk-B, and sk-X:\n\n  sk-A -> sk-B (-> sk-C)\n  sk-X -> sk-X\n\nThis is totally fine.  All of them are not yet close()d and\nshould be grouped into different SCCs.\n\nHowever, unix_vertex_dead() misjudges that sk-A and sk-B are\nin the same SCC and sk-A is dead.\n\n  unix_sk(sk-A)->scc_index == unix_sk(sk-B)->scc_index <-- Wrong!\n  &&\n  sk-A's file refcnt == unix_sk(sk-A)->vertex->out_degree\n                                       ^-- 1 in-flight count for sk-B\n  -> sk-A is dead !?\n\nThe problem is that unix_add_edge() does not initialise scc_index.\n\nStage 1) is used for heap spraying, making a newly allocated\nvertex have vertex->scc_index == 2 (UNIX_VERTEX_INDEX_START)\nset by unix_walk_scc() at 1-c.\n\nLet's track the max SCC index from the previous unix_walk_scc()\ncall and assign the max + 1 to a new vertex's scc_index.\n\nThis way, we can continue to avoid Tarjan's algorithm while\npreventing misjudgments.",
      "severity": "N/A",
      "references": [
        {
          "url": "https://git.kernel.org/stable/c/4cd8d755c7d4f515dd9abf483316aca2f1b7b0f3",
          "type": "reference"
        },
        {
          "url": "https://git.kernel.org/stable/c/db81ad20fd8aef7cc7d536c52ee5ea4c1f979128",
          "type": "reference"
        },
        {
          "url": "https://git.kernel.org/stable/c/1aa7e40ee850c9053e769957ce6541173891204d",
          "type": "reference"
        },
        {
          "url": "https://git.kernel.org/stable/c/60e6489f8e3b086bd1130ad4450a2c112e863791",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "product": "Linux",
          "vendor": "Linux",
          "defaultStatus": "unaffected",
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "programFiles": [
            "net/unix/garbage.c"
          ],
          "versions": [
            {
              "version": "d23802221f6755e104606864067c71af8cdb6788",
              "lessThan": "4cd8d755c7d4f515dd9abf483316aca2f1b7b0f3",
              "status": "affected",
              "versionType": "git"
            },
            {
              "version": "ad081928a8b0f57f269df999a28087fce6f2b6ce",
              "lessThan": "db81ad20fd8aef7cc7d536c52ee5ea4c1f979128",
              "status": "affected",
              "versionType": "git"
            },
            {
              "version": "ad081928a8b0f57f269df999a28087fce6f2b6ce",
              "lessThan": "1aa7e40ee850c9053e769957ce6541173891204d",
              "status": "affected",
              "versionType": "git"
            },
            {
              "version": "ad081928a8b0f57f269df999a28087fce6f2b6ce",
              "lessThan": "60e6489f8e3b086bd1130ad4450a2c112e863791",
              "status": "affected",
              "versionType": "git"
            },
            {
              "version": "adfb68b39b39767d6bfb53e48c4f19c183765686",
              "status": "affected",
              "versionType": "git"
            }
          ]
        },
        {
          "product": "Linux",
          "vendor": "Linux",
          "defaultStatus": "affected",
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "programFiles": [
            "net/unix/garbage.c"
          ],
          "versions": [
            {
              "version": "6.10",
              "status": "affected"
            },
            {
              "version": "0",
              "lessThan": "6.10",
              "status": "unaffected",
              "versionType": "semver"
            },
            {
              "version": "6.6.117",
              "lessThanOrEqual": "6.6.*",
              "status": "unaffected",
              "versionType": "semver"
            },
            {
              "version": "6.12.59",
              "lessThanOrEqual": "6.12.*",
              "status": "unaffected",
              "versionType": "semver"
            },
            {
              "version": "6.17.9",
              "lessThanOrEqual": "6.17.*",
              "status": "unaffected",
              "versionType": "semver"
            },
            {
              "version": "6.18",
              "lessThanOrEqual": "*",
              "status": "unaffected",
              "versionType": "original_commit_for_fix"
            }
          ]
        }
      ],
      "problemType": [],
      "fix_suggestion": "无法生成修复建议"
    }
  ]
}