{
  "dataType": "CVE_RECORD",
  "dataVersion": "5.1",
  "cveMetadata": {
    "total_count": 3,
    "last_updated": "2025-12-19T16:56:20.145690",
    "severity_distribution": {
      "critical": 0,
      "high": 2,
      "medium": 0,
      "low": 0,
      "none": 1
    }
  },
  "cves": [
    {
      "id": "CVE-2025-68477",
      "publishedDate": "2025-12-19T16:43:00.551Z",
      "lastModifiedDate": "2025-12-19T16:43:00.551Z",
      "description": "Langflow is a tool for building and deploying AI-powered agents and workflows. Prior to version 1.7.0, Langflow provides an API Request component that can issue arbitrary HTTP requests within a flow. This component takes a user-supplied URL, performs only normalization and basic format checks, and then sends the request using a server-side httpx client. It does not block private IP ranges (127[.]0[.]0[.]1, the 10/172/192 ranges) or cloud metadata endpoints (169[.]254[.]169[.]254), and it returns the response body as the result. Because the flow execution endpoints (/api/v1/run, /api/v1/run/advanced) can be invoked with just an API key, if an attacker can control the API Request URL in a flow, non-blind SSRF is possible—accessing internal resources from the server’s network context. This enables requests to, and collection of responses from, internal administrative endpoints, metadata services, and internal databases/services, leading to information disclosure and providing a foothold for further attacks. Version 1.7.0 contains a patch for this issue.",
      "severity": 7.7,
      "references": [
        {
          "url": "https://github.com/langflow-ai/langflow/security/advisories/GHSA-5993-7p27-66g5",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "vendor": "langflow-ai",
          "product": "langflow",
          "versions": [
            {
              "version": "< 1.7.0",
              "status": "affected"
            }
          ]
        }
      ],
      "problemType": [
        "CWE-918: Server-Side Request Forgery (SSRF)"
      ],
      "fix_suggestion": "无法生成修复建议"
    },
    {
      "id": "CVE-2025-14809",
      "publishedDate": "2025-12-19T16:39:29.458Z",
      "lastModifiedDate": "2025-12-19T16:39:29.458Z",
      "description": "ArcSearch for Android versions prior to 1.12.6 could display a different domain in the address bar than the content being shown, enabling address bar spoofing after user interaction via crafted web content.",
      "severity": 7.4,
      "references": [
        {
          "url": "https://arc.net/security/bulletins#cve-2025-14809-address-bar-spoofing-risk-navigation-trigger-uri-confusion-on-arcsearch-android",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "defaultStatus": "unaffected",
          "modules": [
            "Address bar / Omnibox (address bar UI)"
          ],
          "platforms": [
            "Android"
          ],
          "product": "ArcSearch",
          "vendor": "The Browser Company of New York",
          "versions": [
            {
              "lessThan": "1.12.6",
              "status": "affected",
              "version": "0",
              "versionType": "semver"
            }
          ]
        }
      ],
      "problemType": [
        "CWE-1021 Improper Restriction of Rendered UI Layers or Frames"
      ],
      "fix_suggestion": "无法生成修复建议"
    },
    {
      "id": "CVE-2025-68457",
      "publishedDate": "2025-12-19T16:40:30.258Z",
      "lastModifiedDate": "2025-12-19T16:40:30.258Z",
      "description": "Orejime is a consent manager that focuses on accessibility. On HTML elements handled by Orejime prior to version 2.3.2, one could run malicious code by embedding `javascript:` code within data attributes. When consenting to the related purpose, Orejime would turn data attributes into unprefixed ones (i.e. `data-href` into `href`), thus executing the code. This shouldn't have any impact on most setups, as elements handled by Orejime are generally hardcoded. The problem would only arise if somebody could inject HTML code within pages. The problem has been patched in version 2.3.2. As a workaround, the problem can be fixed outside of Orejime by sanitizing attributes which could contain executable code.",
      "severity": "N/A",
      "references": [
        {
          "url": "https://github.com/boscop-fr/orejime/security/advisories/GHSA-72mh-hgpm-6384",
          "type": "reference"
        },
        {
          "url": "https://github.com/boscop-fr/orejime/issues/142",
          "type": "reference"
        },
        {
          "url": "https://github.com/boscop-fr/orejime/pull/143",
          "type": "reference"
        }
      ],
      "affected": [
        {
          "vendor": "boscop-fr",
          "product": "orejime",
          "versions": [
            {
              "version": "< 2.3.2",
              "status": "affected"
            }
          ]
        }
      ],
      "problemType": [
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
      ],
      "fix_suggestion": "无法生成修复建议"
    }
  ]
}